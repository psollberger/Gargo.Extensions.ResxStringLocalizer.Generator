namespace Gargo.Extensions.ResxStringLocalizer.Generator;

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Resources.NetStandard;
using System.Text;
using System.Text.RegularExpressions;

using Microsoft.CodeAnalysis;

[Generator]
public class ResXEntryMapGenerator : ISourceGenerator
{
  private static readonly Regex ResXFilePattern = new(@"(?<!\.[A-Za-z]{2,3})\.resx$", RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);
  private static readonly Regex ArgumentPattern = new(@"\{[0-9]{1,2}\}", RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);

  /// <inheritdoc />
  public void Initialize(GeneratorInitializationContext context)
    => ReferenceHandler.Initialize();

  /// <inheritdoc />
  public void Execute(GeneratorExecutionContext context)
  {
    try
    {
      if (!context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDirectory))
        throw new InvalidOperationException("The project directory could not be found.");

      context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.rootnamespace", out var rootNamespace);
      rootNamespace ??= "__NAMESPACE_NOT_FOUND__";

      var resxFiles = context.AdditionalFiles.Where(x => ResXFilePattern.IsMatch(x.Path)).ToArray();

      foreach (var resxFile in resxFiles)
      {
        var generateExtensionMethods = true;

        if (context.AnalyzerConfigOptions.GetOptions(resxFile).TryGetValue("build_metadata.EmbeddedResource.GenerateExtensionMethods", out var generateExtensionMethodsItemValue))
          generateExtensionMethods = !string.Equals(generateExtensionMethodsItemValue, "false", StringComparison.OrdinalIgnoreCase);

        if (!generateExtensionMethods)
          continue;

        var srcText = resxFile.GetText();

        if (srcText is null)
          continue;

        var localizerInterfaceType = GetStringLocalizerInterfaceType(projectDirectory, resxFile);

        var inputFileContent = srcText.ToString();
        var resxReader = new ResXResourceReader(new StringReader(inputFileContent));
        var code = new StringBuilder(inputFileContent.Length);

        code.AppendLine("// <auto-generated/>");
        code.AppendLine($"namespace {rootNamespace}");
        code.AppendLine("{");
        code.AppendLine("  using Microsoft.Extensions.Localization;");
        code.AppendLine("");
        code.AppendLine(@"  internal static partial class LocalizerExtensions");
        code.AppendLine("  {");

        foreach (DictionaryEntry o in resxReader)
        {
          var entryName = o.Key.ToString()!;
          var safeEntryName = MakeSafe(entryName);
          var entryValue = o.Value!.ToString()!;

          var argumentCount = ArgumentPattern.Matches(entryValue).Count;
          var argList = argumentCount == 0 ? Array.Empty<string>() : ArrayPool<string>.Shared.Rent(argumentCount);
          var argTypeList = argumentCount == 0 ? Array.Empty<string>() : ArrayPool<string>.Shared.Rent(argumentCount);
          var argParams = argumentCount == 0 ? Array.Empty<string>() : ArrayPool<string>.Shared.Rent(argumentCount);

          try
          {
            if (argumentCount > 0)
              for (var i = 0; i < argumentCount; ++i)
              {
                argTypeList[i] = $"T{i}";
                argList[i] = $"T{i} arg{i}";
                argParams[i] = $"arg{i}";
              }

            code.AppendLine("    /// <summary>");
            code.AppendLine($"    ///   {entryValue}");
            code.AppendLine("    /// </summary>");

            code.AppendLine(
              argumentCount == 0 ?
                $"    public static string {safeEntryName}(this {localizerInterfaceType} loc)" :
                $"    public static string {safeEntryName}<{string.Join(", ", argTypeList.Take(argumentCount))}>(this {localizerInterfaceType} loc, {string.Join(", ", argList.Take(argumentCount))})"
            );

            code.AppendLine("    {");

            code.AppendLine(
              argumentCount == 0 ?
                $"      return loc[\"{entryName}\"];" :
                $"      return loc[\"{entryName}\", {string.Join(", ", argParams.Take(argumentCount))}];"
            );

            code.AppendLine("    }");
          }
          finally
          {
            if (argumentCount > 0)
            {
              ArrayPool<string>.Shared.Return(argList);
              ArrayPool<string>.Shared.Return(argTypeList);
              ArrayPool<string>.Shared.Return(argParams);
            }
          }
        }

        code.AppendLine("  }");
        code.AppendLine("}");

        var hintName = GetStringLocalizerHintName(projectDirectory, resxFile);
        context.AddSource($"{hintName}.g", code.ToString());
      }
    }
    catch (Exception ex)
    {
      AddExceptionComment(context, $"{nameof(Execute)}.Exception.g", ex);
    }
  }

  private static string MakeSafe(string value)
  {
    var sb = new StringBuilder(value);
    sb.Replace(" ", "_");
    sb.Replace("'", "_");
    sb.Replace("?", "");
    sb.Replace("{", "_");
    sb.Replace("}", "_");
    sb.Replace("(", "_");
    sb.Replace(")", "_");
    sb.Replace(",", "");
    sb.Replace(".", "");
    sb.Replace("<", "");
    sb.Replace(">", "");
    return sb.ToString();
  }

  private static string GetStringLocalizerInterfaceType(string projectDirectory, AdditionalText resxEntry)
  {
    var filePath = resxEntry.Path;
    var stack = new Stack<string>(10);

    if (!filePath.StartsWith(projectDirectory, StringComparison.OrdinalIgnoreCase))
      throw new InvalidOperationException("The resx file doesn't reside in the project directory.");

    string resxPathRelativeToResourceDir = filePath[(filePath.IndexOf('\\', projectDirectory.Length + 1) + 1)..];

    var curDirName = Path.GetFileNameWithoutExtension(resxPathRelativeToResourceDir);
    var curDirNamePath = Path.GetDirectoryName(resxPathRelativeToResourceDir);

    while (!string.IsNullOrEmpty(curDirName))
    {
      stack.Push(Path.GetFileName(curDirName));
      curDirName = Path.GetFileName(curDirNamePath);
      curDirNamePath = Path.GetDirectoryName(curDirNamePath);
    }

    return string.Concat(string.Concat("IStringLocalizer<", string.Join(".", stack)), ">");
  }

  private static string GetStringLocalizerHintName(string projectDirectory, AdditionalText resxEntry)
  {
    var filePath = resxEntry.Path;
    var stack = new Stack<string>(10);

    if (!filePath.StartsWith(projectDirectory, StringComparison.OrdinalIgnoreCase))
      throw new InvalidOperationException("The resx file doesn't reside in the project directory.");

    string resxPathRelativeToResourceDir = filePath[(filePath.IndexOf('\\', projectDirectory.Length + 1) + 1)..];

    var curDirName = Path.GetFileName(resxPathRelativeToResourceDir);
    var curDirNameExtension = Path.GetExtension(curDirName);
    curDirName = curDirName.Replace(curDirNameExtension, curDirNameExtension.Replace('.', '_'));
    var curDirNamePath = Path.GetDirectoryName(resxPathRelativeToResourceDir);

    while (!string.IsNullOrEmpty(curDirName))
    {
      stack.Push(Path.GetFileName(curDirName));
      curDirName = Path.GetFileName(curDirNamePath);
      curDirNamePath = Path.GetDirectoryName(curDirNamePath);
    }

    return string.Join("_", stack);
  }

  private static void AddExceptionComment(GeneratorExecutionContext context, string hintName, Exception ex)
  {
    var code = new StringBuilder();

    code.AppendLine(
      @"// <auto-generated>
//     This code was generated by a tool.
//     Changes will be lost when the code is regenerated.
// </auto-generated>"
    ).AppendLine();

    code.AppendLine("internal static partial class ResXEntryMapGenerator_Exception");
    code.AppendLine("{");
    code.AppendLine("/* EXCEPTION - gnarf ...");
    code.AppendLine(ex.ToString());
    code.AppendLine("*/");
    code.AppendLine("}");

    context.AddSource(hintName, code.ToString());
  }
}
